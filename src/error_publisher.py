#!/usr/bin/env python

import rospy
import tf
import numpy as np
import sys
import os
import utils
from std_msgs.msg import Header
from gazebo_msgs.msg import LinkStates
from std_msgs.msg import Float64
from scipy.interpolate import interp1d
from imu_simulation_framework.msg import ErrorCoordinates2
import ConfigParser

class Error_Publisher:
    """
    Helper ROS node computes in real-time the yaw and euclidian distance errors between the desired waypoint and the current
    position and orientation of the robot in Gazebo simulator.
    Part of imu_simulation_framework ROS node, it should be started as the the second script, after path_follower.

    2018 - 2019, David Cesenek, cesendav@fel.cvut.cz
    """

    def load_reference_trajectory(self, file):
        """
        Loads the reference set of waypoints generated by path_follower and
        saves the data as scipy interpolation functions, to have the direct access
        to the reference values at any time stamp in the interval <time_min, time_max>.
        """
        time, x, y, yaw, _, _ = utils.load_trajectory_data(file)


        self.reference_trajectory['time_min'] = np.amin(time)
        self.reference_trajectory['time_max'] = np.amax(time)

        self.reference_trajectory['x'] = interp1d(x=time, y=x, kind='linear')
        self.reference_trajectory['y'] = interp1d(x=time, y=y, kind='linear')
        self.reference_trajectory['yaw'] = interp1d(x=time, y=yaw, kind='linear')

    def odometry_callback(self, msg):
        """
        Error publisher assumes that there is an additive link in the middle of the axis between the rear wheels.
        Its position is published internaly by Gazebo and subscribed in this callback.
        """
        if not self.reference_link in msg.name:
            rospy.logerr('No link with name: %s found!',self.reference_link)
            return
        names = msg.name
        idx = names.index(self.reference_link)
        self.robot_pose = msg.pose[idx]

    def wheel_velocity_command_callback(self, msg):
        """
        Trigger the error computation, when the wheel velocities start to be produced.
        """
        if self.start_time == 0: # save the start time of experiment
            t = rospy.get_rostime()
            self.start_time = t.to_sec()

    def get_interpolated_reference_data(self, data_type, time):

        try:
            tmp = self.reference_trajectory[data_type]
            result = tmp(time)
        except KeyError:
            rospy.logerr('Key error in function \"get_interpolated_reference_data\"!')
            return None
        except ValueError:
            rospy.logerr('Error cannot be computed, time: %f sec lays out of interpolation range for trajectory reference data"!', time)
            self.out_of_range_samples += 1

            # Implement better ending than this one???
            if self.out_of_range_samples > 10:
                sys.exit(0)
            return None
        return result

    def compute_errors(self):
        """
        Compute the errors and wrap them for path_follwer script into custom ROS topic message.
        """
        if self.start_time != 0:
            # the last captured robot's postion and heading
            position = self.robot_pose.position
            orientation = self.robot_pose.orientation
            t = rospy.get_rostime()

            x = position.x
            y = position.y
            q = (orientation.x, orientation.y, orientation.z, orientation.w)
            euler = tf.transformations.euler_from_quaternion(q)
            yaw = euler[2]

            t_sec = t.to_sec() - self.start_time
            x_ref = self.get_interpolated_reference_data(data_type='x', time=t_sec)
            y_ref = self.get_interpolated_reference_data(data_type='y', time=t_sec)
            yaw_ref = self.get_interpolated_reference_data(data_type='yaw', time=t_sec)

            # If error occures when interpolating data, return negative values to indicate error to controller in path_follower script
            if (x_ref is None) or (y_ref is None) or (yaw_ref is None):
                yaw_error = -1000.0
                x_error = -1000.0
                y_error = -1000.0
                dist_theta = -1000.0
            else:
                yaw_error = utils.compute_angle_difference(yaw_ref, yaw)
                x_error = x_ref - x
                y_error = y_ref - y
                theta = np.arctan2(y_error, x_error) # convert the distance to the angle error to decide
                dist_theta = utils.compute_angle_difference(yaw, theta)

            error_msg = ErrorCoordinates2()
            header = Header()
            header.seq = self.seq
            header.stamp = t
            error_msg.header = header
            error_msg.yaw_error = yaw_error
            error_msg.x_error = x_error
            error_msg.y_error = y_error
            error_msg.dist_theta = dist_theta
            error_msg.lead = 0

            return error_msg
        else:
            return None

    def load_parameters(self, ini_file):
        """
        Load paramters from the given ini config file.
        """

        config = ConfigParser.SafeConfigParser()

        if os.path.isfile(ini_file):
            config.read(ini_file)
        else:

            rospy.logerr("Error, the config file: %s not found!", ini_file)
            return False
        try:
            rospy.loginfo('Loading the parameters from config file:%s \n--------------------------------------------------')

            self.output_dir = config.get('common','output_dir')
            rospy.loginfo("output_dir set to:%s",self.output_dir)

            self.rear_wheel_velocity_left_topic = config.get('common', 'rear_wheel_velocity_left_topic')
            rospy.loginfo("rear_wheel_velocity_left_topic set to:%s",self.rear_wheel_velocity_left_topic)

            self.rear_wheel_velocity_right_topic = config.get('common', 'rear_wheel_velocity_right_topic')
            rospy.loginfo("rear_wheel_velocity_right_topic set to:%s",self.rear_wheel_velocity_right_topic)

            self.reference_link = config.get('common', 'middlepoint_link')
            rospy.loginfo("middlepoint_link set to:%s", self.reference_link)

            rospy.loginfo('--------------------------------------------------\n')
        except ConfigParser.NoSectionError as e:
            rospy.logerr("NoSectionError when parsing the config file: %s", ini_file)
            rospy.logerr(e)
            return False
        except ConfigParser.NoOptionError as e:
            rospy.logerr("NoOptionError  when parsing the config file: %s", ini_file)
            rospy.logerr(e)
            return False

        return True

    def __init__(self, ini_file):
        """
        A node computing the error of robot's position and orientation and publishing it as a custom ros topic to controll the robot's movement in the feedback loop.

        example:

        """
        rospy.init_node('error_publisher')

        self.rear_wheel_velocity_left_topic = 'command_r'
        self.rear_wheel_velocity_right_topic = 'command_l'
        self.output_dir = 'simulation_log/'
        self.seq = 0
        self.reference_link = 'robot::middle_link'
        self.reference_trajectory = {}
        self.lead = 0.0 # how much further in the future the distance error should be considered
        self.start_time = 0
        self.out_of_range_samples = 0

        self.load_parameters(ini_file)
        # rospy.sleep(5) # sleep 5 seconds to give path_follower enough time to load the data

        self.load_reference_trajectory(self.output_dir + 'trajectory_data.csv')

        rospy.Subscriber("/gazebo/link_states", LinkStates, self.odometry_callback)
        rospy.Subscriber(self.rear_wheel_velocity_left_topic, Float64, self.wheel_velocity_command_callback)
        rospy.Subscriber(self.rear_wheel_velocity_right_topic, Float64, self.wheel_velocity_command_callback)
        pub = rospy.Publisher('error_coordinates2', ErrorCoordinates2, queue_size=10)

        rate = rospy.Rate(50)
        rospy.loginfo("error_publisher ROS node initialized!")

        while not rospy.is_shutdown():
            error_msg = self.compute_errors()
            if error_msg is not None:
                pub.publish(error_msg)
            rate.sleep()

if __name__ == '__main__':
    try:
        if len(sys.argv) >1 :
            ep = Error_Publisher(sys.argv[1])
        else:
            raise AssertionError
    except AssertionError:
        print("Error_publisher error, no ini. config given!")

    except rospy.ROSInterruptException,e:
        rospy.logerr("%s", e)